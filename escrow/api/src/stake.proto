syntax = "proto3";

import "common/api/src/common.proto";

package escrow;

service Stake {
  rpc DepositStake (DepositStakeRequest) returns (DepositStakeResponse) {}
  rpc ReleaseStake (ReleaseStakeRequest) returns (ReleaseStakeResponse) {}
  rpc AllocateEscrow (AllocateEscrowRequest) returns (AllocateEscrowResponse) {}
  rpc ListActiveEscrows (ListActiveEscrowsRequest)
    returns (ListActiveEscrowsResponse) {}
  rpc VerifyEscrow (VerifyEscrowRequest)
    returns (VerifyEscrowResponse) {}
  rpc TakeAndReleaseEscrow (TakeAndReleaseEscrowRequest)
    returns (TakeAndReleaseEscrowResponse) {}
}

// Message fields annotated with /* $$ */ is where conceptually
// cryptocurrency tokens are transferred.

// Per-caller state:
//  uint64 amount:  total stake amount
//  uint64 escrowed:  amount of stake in escrow
//  map<uint128, pair<entity, uint64>> escrow_map:  map from
//    uuid for in-flight escrows and the entity and amount of the escrow

// Invariants:
//
// 0 <= escrowed <= amount <= MAX_UINT64
//
// \sum_{\forall (uuid, escrow) in escrow_map} escrow.second <= MAX_UINT64
//   (i.e., sum calculation does not overflow)
//
// \sum_{\forall (uuid, escrow) in escrow_map} escrow.second = escrowed

message DepositStakeRequest {
  // Deposit an additional |amount| into the caller's bond/escrow account
  uint64 amount = 1;  /* $$ */
}
// Post: caller.amount <= caller.amount'  (new amount is at least previous)
// If caller.amount + DepositStakeRequest.amount <= MAX_UINT64,
// caller.amount' = caller.amount + DepositStakeRequest.amount
// else caller.amount' = caller.amount and the call returns
// with Err(StakeWouldOverflow)

message DepositStakeResponse {
  // Other than some internal error (out of memory? out of gas for
  // processing the request?), the only possible reason for failure is
  // integer overflow.  That would be amazing....
  uint32 failure_code = 1;
}

// If ReleaseStakeRequest.amount_requested <= caller.amount -
// caller.escrowed then
//   caller.amount' = caller.amount - ReleaseStakeRequested.amount_requested
//   amount_returned = ReleaseStakeRequest.amount_requested
//   failure_code = 0 (OK(()));
// otherwise
//   caller state unchanged
//   failure_code = Err(InsufficientStakeAvailable)
message ReleaseStakeRequest {
  uint64 amount_requested = 1;
}

message ReleaseStakeResponse {
  uint32 failure_code = 1;
  uint64 amount_returned = 2;  /* $$ */
}

// If caller.stake - caller.escrowed >= AllocateEscrowRequest.escrow_amount
// then
//   uuid = generate_id()
//   caller.escrow_map[uuid] = pair(entity, escrow_amount)
//   caller.escrowed += AllocateEscrowRequest.escrow_amount
//   failure_code = Ok(())
// otherwise
//   caller state unchanged
//   failure_code = Err(WouldOverflow)
message AllocateEscrowRequest {
  // Set aside from the caller's deposited bond for use with
  // transactions with |entity| the |escrow_amount|, with an
  // |escrow_id| uuid returned.
  //
  // The set-aside values are split apart from the total
  // bond remaining, and |entity| can do the following operations:
  //
  // - VerifyEscrow (escrow_id, escrow_amount) tuple is valid.
  // - TakeAndReleaseEscrow (escrow_id, n)  n <= amount, amount-n is released.
  //   (To release entire escrow, use n=0.)
  common.Entity entity = 1;
  uint64 escrow_amount = 2;
}

message AllocateEscrowResponse {
  // Failure reasons:
  // -  insufficient funds.
  uint32 failure_code = 1;
  bytes id = 2;  // Should be uuid, so no two the same.
}
// The returned escrow id is an identifier and not an authenticator,
// and instead of a randomly chosen uuid (i.e., version 4, with 122
// random bits), this could be non-RFC 4122 compliant sequence number
// to make this deterministic.

message EscrowData {
  bytes id = 1;
  common.Entity entity = 2;
  uint64 amount = 3;
}

message ListActiveEscrowsRequest {
}

message ListActiveEscrowsResponse {
  repeated EscrowData escrows = 1;
}

message VerifyEscrowRequest {
  EscrowData escrow = 1;
}

message VerifyEscrowResponse {
  uint32 failure_code = 1;
  // 0 means Ok(()), other values mean Err(NoSuchId),
  // Err(EntityMismatch), Err(AmountMismatch)
}

message TakeAndReleaseEscrowRequest {
  bytes id = 1;
  uint64 amount = 2;
}

message TakeAndReleaseEscrowResponse {
  uint32 failure_code = 1;
  // 0 means Ok(amount), other values mean
  // Err(NoSuchId), Err(InsufficentEscrow)
  uint64 amount = 2;  /* $$ */
}
