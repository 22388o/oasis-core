syntax = "proto3";

import "common/api/src/common.proto";

package escrow;

service Stake {
  rpc DepositStake (DepositStakeRequest) returns (DepositStakeResponse) {}
  rpc ReleaseStake (ReleaseStakeRequest) returns (ReleaseStakeResponse) {}
  rpc AllocateEscrow (AllocateEscrowRequest) returns (AllocateEscrowResponse) {}
  rpc ListActiveEscrows (ListActiveEscrowsRequest)
    returns (ListActiveEscrowsResponse) {}
  rpc FetchEscrowById (FetchEscrowByIdRequest)
    returns (FetchEscrowByIdResponse) {}
  rpc TakeAndReleaseEscrow (TakeAndReleaseEscrowRequest)
    returns (TakeAndReleaseEscrowResponse) {}
}

// Message fields annotated with $$ is where conceptually
// cryptocurrency tokens are transferred.

// Per-caller state:
//  uint64 amount:  total stake amount
//  uint64 escrowed:  amount of stake in escrow
//  map<uint128, pair<entity, uint64>> escrow_map:  map from
//    uuid for in-flight escrows and the entity and amount of the escrow

// Invariants:
//
// 0 <= escrowed <= amount <= MAX_UINT64
//
// \sum_{\forall (uuid, escrow) in escrow_map} escrow.second <= MAX_UINT64
//   (i.e., sum calculation does not overflow)
//
// \sum_{\forall (uuid, escrow) in escrow_map} escrow.second = escrowed

message DepositStakeRequest {
  // Deposit an additional |amount| into the caller's bond/escrow account
  uint64 amount = 1;  // $$
  common.Entity msg_sender = 2;
  // This corresponds to msg.sender in Solidity; it should be an
  // address, which could be the SHA1 hash of a public key (external
  // address) or a contract address (blockchain address) [addresses
  // are 160 bit values].  In the context of grpc, this would be
  // RpcContext's auth_context()'s GetPeerIdentity(), which probably
  // would come from the identity in a JWT.
}
// Post: caller.amount <= caller.amount'  (new amount is at least previous)
// If caller.amount + DepositStakeRequest.amount <= MAX_UINT64,
// caller.amount' = caller.amount + DepositStakeRequest.amount
// else caller.amount' = caller.amount and the call returns
// with Err(StakeWouldOverflow)

message DepositStakeResponse {
  // Other than some internal error (out of memory? out of gas for
  // processing the request?) which should be handled by the Rust/grpc
  // framework, the only possible reason for failure is integer
  // overflow.  Handled via Err(...) which propagates through the
  // grpc layer.
}

// If ReleaseStakeRequest.amount_requested <= caller.amount -
// caller.escrowed then
//   caller.amount' = caller.amount - ReleaseStakeRequested.amount_requested
//   amount_returned = ReleaseStakeRequest.amount_requested
//   failure_code = 0 (OK(()));
// otherwise
//   caller state unchanged
//   failure_code = Err(InsufficientStakeAvailable)
message ReleaseStakeRequest {
  uint64 amount_requested = 1;
}

message ReleaseStakeResponse {
  uint64 amount_returned = 1;  // $$
}

// *TODO*: do escrows expire?  If the entity to which the escrow was
// made via AllocateEscrow disappears, would all funds escrowed to it
// also disappear?  If escrow includes a time limit, then we need some
// security guarantees about the validity of time, so that an attacker
// could not trick the stake escrow service to expire an escrow
// earlier than it should.  (Multisig time service ought to work,
// since setting the clock back via replaying old messages doesn't
// help the attacker in this situation.  Releasing escrowed funds a
// little later than we should is just another denial-of-service
// attack.)
//
// If caller.stake - caller.escrowed >= AllocateEscrowRequest.escrow_amount
// then
//   uuid = generate_id()
//   caller.escrow_map[uuid] = pair(entity, escrow_amount)
//   caller.escrowed += AllocateEscrowRequest.escrow_amount
//   failure_code = Ok(())
// otherwise
//   caller state unchanged
//   failure_code = Err(WouldOverflow)
message AllocateEscrowRequest {
  // Set aside from the caller's deposited bond for use with
  // transactions with |entity| the |escrow_amount|, with an
  // |escrow_id| uuid returned.
  //
  // The set-aside values are split apart from the total
  // bond remaining, and |entity| can do the following operations:
  //
  // - FetchEscrowById (escrow_id, entity, escrow_amount) tuple is valid.
  // - TakeAndReleaseEscrow (escrow_id, n)  n <= amount, amount-n is released.
  //   (To release entire escrow, use n=0.)
  common.Entity entity = 1;
  uint64 escrow_amount = 2;
}

message AllocateEscrowResponse {
  // Failure reasons: Err(InsufficientFunds).
  bytes id = 1;  // Should be uuid, so no two the same.
}
// The returned escrow id is an identifier and not an authenticator,
// and instead of a randomly chosen uuid (i.e., version 4, with 122
// random bits), this could be non-RFC 4122 compliant sequence number
// to make this deterministic.

message EscrowData {
  bytes id = 1;
  common.Entity entity = 2;
  uint64 amount = 3;
}

// This is useful for the msg.sender to know what escrows are still
// outstanding.
message ListActiveEscrowsRequest {
}

message ListActiveEscrowsResponse {
  repeated EscrowData escrows = 1;
}

// Rather than sending the entity and amount information, we just
// allow querying by the escrow id.  The caller (library) can verify
// that entity address matches and that the amount that was set aside
// is sufficent.
message FetchEscrowByIdRequest {
  bytes id = 1;
}

message FetchEscrowByIdResponse {
  // Possible errors: Err(NoSuchId)
  EscrowData escrow = 1;
}

message TakeAndReleaseEscrowRequest {
  bytes id = 1;
  uint64 amount = 2;
}

message TakeAndReleaseEscrowResponse {
  // Possible failures: Err(NoSuchId), Err(InsufficentFunds)
  uint64 amount = 1;  // $$
}
