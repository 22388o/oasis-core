//! Dependency injection.
use std::any::{Any, TypeId};
use std::collections::HashMap;
#[cfg(not(all(feature = "cli", not(target_env = "sgx"))))]
use std::marker::PhantomData;
use std::sync::Arc;

#[cfg(all(feature = "cli", not(target_env = "sgx")))]
use clap;

use super::error::Result;

/// Component descriptor.
pub struct ComponentDescriptor {
    /// Type of component.
    pub component: TypeId,
    /// Type of trait this component is registered for.
    pub impl_trait: TypeId,
    /// Factory for creating component instances.
    pub factory: Box<ComponentFactory>,
}

/// Known component registry.
pub struct KnownComponents {
    /// Registered components.
    components: HashMap<TypeId, ComponentDescriptor>,
}

impl KnownComponents {
    /// Construct a new component registry instance.
    pub fn new() -> Self {
        Self {
            components: HashMap::new(),
        }
    }

    /// Inject arguments for configuring registered components.
    ///
    /// For each component we add two kinds of arguments:
    /// * Selector for choosing the actual component that will get instantiated. The
    ///   argument is named after the group name returned by [`ComponentFactory::get_group`]
    /// * Component-specific arguments which are generated by the component.
    #[cfg(all(feature = "cli", not(target_env = "sgx")))]
    pub fn get_arguments(&self) -> Vec<clap::Arg<'static, 'static>> {
        let mut groups = HashMap::new();
        let mut arguments = vec![];
        for component in self.components.values() {
            groups
                .entry(component.factory.get_group())
                .or_insert(vec![])
                .push(component.factory.get_name());

            arguments.append(&mut component
                .factory
                .get_arguments()
                .iter()
                .map(|argument| {
                    let mut argument = argument.clone();

                    // Map required to required_if component is selected.
                    if argument.is_set(clap::ArgSettings::Required) {
                        argument = argument.unset(clap::ArgSettings::Required).required_if(
                            component.factory.get_group(),
                            component.factory.get_name(),
                        );
                    }

                    argument
                })
                .collect());
        }

        arguments.append(&mut groups
            .iter()
            .filter(|&(_, choices)| choices.len() > 1)
            .map(|(group, choices)| {
                clap::Arg::with_name(group)
                    .long(group)
                    .takes_value(true)
                    .possible_values(choices)
                    .required(true)
            })
            .collect());

        arguments
    }

    /// Register a component for a given trait.
    pub fn register<C: Component, T: ?Sized + 'static>(&mut self) {
        let type_id = TypeId::of::<C>();
        let descriptor = ComponentDescriptor {
            component: type_id.clone(),
            impl_trait: TypeId::of::<T>(),
            factory: Box::new(C::Factory::new()),
        };

        assert!(
            !self.components.contains_key(&type_id),
            "cannot register the same component twice"
        );

        self.components.insert(type_id, descriptor);
    }

    /// Build a container from the registry, taking arguments into account.
    #[cfg(all(feature = "cli", not(target_env = "sgx")))]
    pub fn build_with_arguments<'a>(
        mut self,
        args: &clap::ArgMatches<'a>,
    ) -> Result<Container<'a>> {
        // Filter out components which were not selected.
        self.components = self.components
            .into_iter()
            .filter(
                |&(_, ref component)| match args.value_of(component.factory.get_group()) {
                    None => true,
                    Some(name) if name == component.factory.get_name() => true,
                    _ => false,
                },
            )
            .collect();

        self.build().map(|container| container.with_arguments(args))
    }

    /// Build a container from the registry.
    pub fn build<'a>(self) -> Result<Container<'a>> {
        // Ensure no duplicate traits.
        {
            let duplicates: Vec<&ComponentDescriptor> = self.components
                .iter()
                .map(|(_, component)| component)
                .filter(|component| {
                    self.components.iter().any(|(_, other)| {
                        component.component != other.component
                            && component.impl_trait == other.impl_trait
                    })
                })
                .collect();

            if !duplicates.is_empty() {
                return Err("duplicated types".into());
            }
        }

        // Compute inverse mapping (traits to components) as we will be instantiating traits.
        let reversed = self.components
            .into_iter()
            .map(|(_, component)| (component.impl_trait.clone(), component))
            .collect();

        Ok(Container::new(reversed))
    }
}

/// Component factory.
pub trait ComponentFactory: Sync + Send {
    /// Construct a new factory.
    fn new() -> Self
    where
        Self: Sized;

    /// Get unique component name.
    fn get_name(&self) -> &'static str {
        "unknown"
    }

    /// Get unique component group.
    fn get_group(&self) -> &'static str {
        "unknown"
    }

    /// Build a new component instance.
    ///
    /// This method must return a type-erased `Box<Arc<Trait>>` otherwise the container
    /// will panic during injection.
    fn build(&self, container: &mut Container) -> Result<Box<Any>>;

    /// Get command line arguments for configuring the component.
    #[cfg(all(feature = "cli", not(target_env = "sgx")))]
    fn get_arguments(&self) -> Vec<clap::Arg<'static, 'static>> {
        vec![]
    }
}

/// Component.
pub trait Component: Send + Sync + 'static {
    type Factory: ComponentFactory;

    /// Register itself with the component registry.
    fn register(registry: &mut KnownComponents);
}

/// Type which can never exist.
#[cfg(not(all(feature = "cli", not(target_env = "sgx"))))]
enum Never {}

/// Component container.
///
/// The container can be used to instantiate components.
pub struct Container<'a> {
    /// Component descriptors from the registry.
    components: HashMap<TypeId, ComponentDescriptor>,
    /// Component instances.
    instances: HashMap<TypeId, Box<Any>>,
    /// Optional arguments.
    #[cfg(all(feature = "cli", not(target_env = "sgx")))]
    arguments: Option<clap::ArgMatches<'a>>,
    #[cfg(not(all(feature = "cli", not(target_env = "sgx"))))]
    _arguments: PhantomData<&'a Never>,
}

impl<'a> Container<'a> {
    /// Create a new component container.
    fn new(components: HashMap<TypeId, ComponentDescriptor>) -> Self {
        Self {
            components,
            instances: HashMap::new(),
            #[cfg(not(all(feature = "cli", not(target_env = "sgx"))))]
            _arguments: PhantomData,
            #[cfg(all(feature = "cli", not(target_env = "sgx")))]
            arguments: None,
        }
    }

    /// Set arguments used for configuring this container.
    #[cfg(all(feature = "cli", not(target_env = "sgx")))]
    pub fn with_arguments(mut self, args: &clap::ArgMatches<'a>) -> Self {
        self.arguments = Some(args.clone());
        self
    }

    #[cfg(all(feature = "cli", not(target_env = "sgx")))]
    pub fn get_arguments(&self) -> Option<&clap::ArgMatches> {
        self.arguments.as_ref()
    }

    /// Inject a component.
    pub fn inject<T: ?Sized + 'static>(&mut self) -> Result<Arc<T>> {
        let type_id = TypeId::of::<T>();

        // Check for existing instance.
        if self.instances.contains_key(&type_id) {
            let instance = self.instances.remove(&type_id).unwrap();
            // Unwrap here is safe as type was checked on initial construction.
            let arc = instance.downcast::<Arc<T>>().unwrap();
            let clone = arc.clone();
            self.instances.insert(type_id, Box::new(*arc));

            return Ok(*clone);
        }

        // Create new instance.
        let component = match self.components.remove(&type_id) {
            Some(component) => component,
            None => return Err("component not found".into()),
        };

        let instance = component.factory.build(self)?;
        let arc = instance
            .downcast::<Arc<T>>()
            .expect("component factory must return boxed Arc<T>");
        let clone = arc.clone();
        self.instances.insert(type_id, Box::new(*arc));

        Ok(*clone)
    }
}

#[cfg(test)]
pub mod test {
    use super::*;

    // Component "Foo".

    trait FooTrait: Send + Sync {
        fn hello(&self) -> u8;
    }

    struct Foo;

    impl Foo {
        pub fn new() -> Self {
            Foo
        }
    }

    impl FooTrait for Foo {
        fn hello(&self) -> u8 {
            42
        }
    }

    create_component!(foo, "foo_trait", Foo, FooTrait, []);

    // Component "Bar" with dependency on "FooTrait".

    trait BarTrait: Send + Sync {
        fn say_hi(&self) -> u8;
    }

    struct Bar {
        // Dependency on Foo.
        foo: Arc<FooTrait>,
    }

    impl Bar {
        pub fn new(foo: Arc<FooTrait>) -> Self {
            Self { foo }
        }
    }

    impl BarTrait for Bar {
        fn say_hi(&self) -> u8 {
            self.foo.hello() * 2
        }
    }

    create_component!(bar, "bar_trait", Bar, BarTrait, [FooTrait]);

    #[test]
    fn test_registry() {
        let mut registry = KnownComponents::new();
        Foo::register(&mut registry);
        Bar::register(&mut registry);

        let mut container = registry.build().unwrap();

        let a = container.inject::<FooTrait>().unwrap();
        let b = container.inject::<FooTrait>().unwrap();
        let c = container.inject::<FooTrait>().unwrap();
        assert_eq!(a.hello(), 42);
        assert_eq!(b.hello(), 42);
        assert_eq!(c.hello(), 42);

        let c = container.inject::<BarTrait>().unwrap();
        assert_eq!(c.say_hi(), 84);
    }
}
