syntax = "proto3";

// This is the stake token and escrow service.  The stake token aspect
// of the service is ERC20 compliant.  Entities hold/transfer/burn
// stake tokens, and can create escrow accounts for which the service
// acts as the escrow agent to enforce the (simple) escrow scenario:
// the ``target'' of the escrow account and the stakeholder has some
// agreement (unspecified), and the target will, at the conclusion of
// the agreement, close the escrow account, claiming some, none, or
// all of the escrowed tokens as forfeiture, with the remainder, if
// any, returned to the stakeholder.  The assumption is that the
// stakeholder will not create an escrow account for a target unless
// the stakeholder knows (via code auditing) that the target will not
// claim the escrowed tokens arbitrarily.

package stake;

service Stake {
  rpc GetName (GetNameRequest)
    returns (GetNameResponse) {}
  rpc GetSymbol (GetSymbolRequest)
    returns (GetSymbolResponse) {}
  rpc GetDecimals (GetDecimalsRequest)
    returns (GetDecimalsResponse) {}
  rpc GetTotalSupply (GetTotalSupplyRequest)
    returns (GetTotalSupplyResponse) {}
  rpc GetStakeStatus (GetStakeStatusRequest)
    returns (GetStakeStatusResponse) {}
  rpc BalanceOf (BalanceOfRequest)
    returns (BalanceOfResponse) {}
  rpc Transfer (TransferRequest)
    returns (TransferResponse) {}
  rpc TransferFrom (TransferFromRequest)
    returns (TransferFromResponse) {}
  rpc Approve (ApproveRequest)
    returns (ApproveResponse) {}
  rpc ApproveAndCall(ApproveAndCallRequest) // cannot make calls in dummy impl
    returns (ApproveAndCallResponse) {}
  rpc Allowance (AllowanceRequest)
    returns (AllowanceResponse) {}
  rpc Burn (BurnRequest)
    returns (BurnResponse) {}
  rpc BurnFrom (BurnFromRequest)
    returns (BurnFromResponse) {}
  rpc AllocateEscrow (AllocateEscrowRequest)
    returns (AllocateEscrowResponse) {}
  rpc ListActiveEscrowsIterator (ListActiveEscrowsIteratorRequest)
    returns (ListActiveEscrowsIteratorResponse) {}
  rpc ListActiveEscrowsGet(ListActiveEscrowsGetRequest)
    returns (ListActiveEscrowsGetResponse) {}
  rpc FetchEscrowById (FetchEscrowByIdRequest)
    returns (FetchEscrowByIdResponse) {}
  rpc TakeAndReleaseEscrow (TakeAndReleaseEscrowRequest)
    returns (TakeAndReleaseEscrowResponse) {}
}

// The RPCs should go over a secured channel so that authentication
// for msg_sender is provided (out-of-band in the communication
// security layer, so the explicit field can be removed), message
// authenticity and freshness is guaranteed, with message
// confidentiality being optional.  The RPC context has this info.

message GetNameRequest {
}

message GetNameResponse {
  string name = 1;
}

message GetSymbolRequest {
}

message GetSymbolResponse {
  string symbol = 1;
}

message GetDecimalsRequest {
}

message GetDecimalsResponse {
  uint32 decimals = 1;  // uint8
}

message GetTotalSupplyRequest {
}

message GetTotalSupplyResponse {
  bytes total_supply = 1;  // AmountType
}

// uint256 is used for stake quantities in this API.  This must
// match the definition of AmountType in the base backend trait
// definition.

// Per-caller state:
//  uint256 amount:  total stake amount
//  uint256 escrowed:  amount of stake in escrow
//  map<uint256, pair<uint256, uint256>> escrow_map:  map from
//    uuid for escrow accounts to the target address and amount of the escrow

// Invariants:
//
// 0 <= escrowed <= amount <= MAX_UINT256
//
// \sum_{\forall (uuid, escrow) in escrow_map} escrow.second <= MAX_UINT256
//   (i.e., sum calculation does not overflow)
//
// \sum_{\forall (uuid, escrow) in escrow_map} escrow.second = escrowed

// The authenticated caller can get their own stake information.  For
// now, we do not expect it to be useful/desirable to query for other
// entity's stake availability etc, though that could change.
message GetStakeStatusRequest {
  bytes owner = 1;
}

message GetStakeStatusResponse {
  bytes total_stake = 1;
  bytes escrowed_stake = 2;
}
// Available stake for withdrawal is total_stake - escrowed_stake.

message BalanceOfRequest {
  bytes owner = 1;
}

message BalanceOfResponse {
  bytes available_balance = 1;
}

// Transfer |amount| stake from the stake account belonging to
// |msg_sender| to that belonging to |target|.  If no account exists
// for |target|, it is automatically created.
message TransferRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes destination_address = 2;
  bytes value = 3;
}

// If there is no overflow in adding to the target account, or
// underflow in deducting from the msg_sender account, then the null
// response would indicate success.  Otherwise an error would be
// reported.
message TransferResponse {
  bool success = 1;
}

message TransferFromRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes source_address = 2;
  bytes destination_address = 3;
  bytes value = 4;
}

message TransferFromResponse {
  bool success = 1;
}

message ApproveRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes spender_address = 2;
  bytes value = 3;
}

message ApproveResponse {
  bool success = 1;
}

message ApproveAndCallRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes spender_address = 2;
  bytes value = 3;
  bytes extra_data = 4;
}

message ApproveAndCallResponse {
  bool success = 1;
}

message AllowanceRequest {
  bytes owner_address = 1;
  bytes spender_address = 2;
}

message AllowanceResponse {
  bytes remaining = 1;
}

message BurnRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes value = 2;
}

message BurnResponse {
  bool success = 1;
}

message BurnFromRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes owner_address = 2;
  bytes value = 3;
}

message BurnFromResponse {
  bool success = 1;
}

// The authenticated caller takes some portion of their available
// stake and create an escrow for use with a named target entity.  If
// the target entity decides that the caller has not met their
// obligation in a transaction, the target may take this escrow
// amount; on the other hand, if all is well, the target may release
// it back to the caller.
//
// *TODO*: do escrows expire?  If the entity to which the escrow was
// made via AllocateEscrow disappears (becomes inaccessible), would
// all funds escrowed to it also disappear (also become inaccessible)?
// If escrow includes a time limit, then we need some security
// guarantees about the validity of time, so that an attacker could
// not trick the stake escrow service to expire an escrow earlier than
// it should.  (Multisig time service ought to work, since setting the
// clock back via replaying old messages doesn't help the attacker in
// this situation.  Releasing escrowed funds a little later than we
// should is just another denial-of-service attack.)
//
// If caller.stake - caller.escrowed >= AllocateEscrowRequest.escrow_amount
// then
//   uuid = generate_id()
//   caller.escrow_map[uuid] = pair(entity, escrow_amount)
//   caller.escrowed += AllocateEscrowRequest.escrow_amount
//   failure_code = Ok(())
// otherwise
//   caller state unchanged
//   failure_code = Err(WouldOverflow)
message AllocateEscrowRequest {
  bytes msg_sender = 1;
  // Set aside from the caller's deposited bond for use with
  // transactions with |entity| the |escrow_amount|, with an
  // |escrow_id| uuid returned.
  //
  // The set-aside values are split apart from the total
  // bond remaining, and |entity| can do the following operations:
  //
  // - FetchEscrowById (escrow_id, entity, escrow_amount) tuple is valid.
  // - TakeAndReleaseEscrow (escrow_id, n)  n <= amount, amount-n is released.
  //   (To release entire escrow, use n=0.)
  bytes target = 2;
  bytes escrow_amount = 3;
  bytes aux = 4;
}

message AllocateEscrowResponse {
  // Failure reasons: Err(InsufficientFunds).
  bytes escrow_id = 1;
}
// The returned escrow id is an identifier and not an authenticator,
// and instead of a randomly chosen uuid (i.e., version 4, with 122
// random bits), this could be non-RFC 4122 compliant sequence number
// to make this deterministic.

message ListActiveEscrowsIteratorRequest {
  bytes owner = 1;
}

message ListActiveEscrowsIteratorResponse {
  bool has_next = 1;
  // EscrowAccountIterator's owner field is omitted
  bytes state = 2; // opaque
}

message ListActiveEscrowsGetRequest {
  // EscrowAccountIterator's has_next field is omitted
  bytes owner = 1;
  bytes state = 2;
}

message ListActiveEscrowsGetResponse {
  bytes escrow_id = 1;
  bytes target = 2;
  bytes amount = 3;
  bytes aux = 4;
  bool has_next = 5;
  bytes state = 6;
}
  

// Rather than sending the entity and amount information, we just
// allow querying by the escrow id.  The caller (library) can verify
// that entity address matches and that the amount that was set aside
// is sufficent.  TODO: do we want to allow this only by the
// stakeholder/owner of the escrow account or the escrow target?
message FetchEscrowByIdRequest {
  bytes escrow_id = 1;
}

message FetchEscrowByIdResponse {
  // Possible errors: Err(NoSuchEscrowId)
  bytes escrow_id = 1;
  bytes target = 2;
  bytes amount = 3;
  bytes aux = 4;
}

// The authenticated caller indicates that he transactions for which
// the escrow was created is done, and the escrow account identified
// by |escrow_id| should be liquidated.  If the escrow account owner
// has met their obligations, the |amount_requested| could be zero,
// and the balance would be returned to the creator of the escrow
// account.  Otherwise, the entire amount specified by |escrow_id|
// could be forefeited and claimed by |msg_sender|.

// msg_sender should have an account, or one will be created for it.
message TakeAndReleaseEscrowRequest {
  bytes msg_sender = 1;
  bytes escrow_id = 2;
  bytes amount_requested = 3;
}

message TakeAndReleaseEscrowResponse {
  // Possible failures: Err(NoSuchEscrowId), Err(InsufficentFunds)
  bytes amount_taken = 1;
  // amount transferred to target (caller)'s stake account.  If there
  // is no Err(..), amount_taken should always equal amount_requested
  // in the request message.  If there is escrow any left over, it is
  // released into the stakeholder's account and available for
  // withdrawal via WithdrawStakeRequest
}
