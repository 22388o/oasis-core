syntax = "proto3";

// This is the stake token and escrow service.  The stake token aspect
// of the service is ERC20 compliant.  Entities hold/transfer/burn
// stake tokens.  Escrow is used only in interaction with the DisputeResolution
// and EntityRegistry services.
//
// Each entity (stakeholder) has a single pot of escrowed tokens that it
// can add to using `AddEscrow`.  Only the DisputeResolution/Consensus service
// can take away escrowed tokens (as forfeiture) with `TakeEscrow` and only
// the EntityRegistry can return the remainder of the escrow (or all of it if
// there were no forfeitures) to the stakeholder with `ReleaseEscrow`.
// The current amount of escrowed tokens for a given entity can be seen with
// `FetchEscrowAmount`.

package stake;

service Stake {
  rpc GetName (GetNameRequest)
    returns (GetNameResponse) {}
  rpc GetSymbol (GetSymbolRequest)
    returns (GetSymbolResponse) {}
  rpc GetDecimals (GetDecimalsRequest)
    returns (GetDecimalsResponse) {}
  rpc GetTotalSupply (GetTotalSupplyRequest)
    returns (GetTotalSupplyResponse) {}
  rpc GetStakeStatus (GetStakeStatusRequest)
    returns (GetStakeStatusResponse) {}
  rpc BalanceOf (BalanceOfRequest)
    returns (BalanceOfResponse) {}
  rpc Transfer (TransferRequest)
    returns (TransferResponse) {}
  rpc TransferFrom (TransferFromRequest)
    returns (TransferFromResponse) {}
  rpc Approve (ApproveRequest)
    returns (ApproveResponse) {}
  rpc ApproveAndCall(ApproveAndCallRequest) // cannot make calls in dummy impl
    returns (ApproveAndCallResponse) {}
  rpc Allowance (AllowanceRequest)
    returns (AllowanceResponse) {}
  rpc Burn (BurnRequest)
    returns (BurnResponse) {}
  rpc BurnFrom (BurnFromRequest)
    returns (BurnFromResponse) {}
  rpc AddEscrow (AddEscrowRequest)
    returns (AddEscrowResponse) {}
  rpc FetchEscrowAmount (FetchEscrowAmountRequest)
    returns (FetchEscrowAmountResponse) {}
  rpc TakeEscrow (TakeEscrowRequest)
    returns (TakeEscrowResponse) {}
  rpc ReleaseEscrow (ReleaseEscrowRequest)
    returns (ReleaseEscrowResponse) {}
  rpc LinkToDisputeResolution (LinkToDisputeResolutionRequest)
    returns (LinkToDisputeResolutionResponse) {}
  rpc LinkToEntityRegistry (LinkToEntityRegistryRequest)
    returns (LinkToEntityRegistryResponse) {}
}

// The RPCs should go over a secured channel so that authentication
// for msg_sender is provided (out-of-band in the communication
// security layer, so the explicit field can be removed), message
// authenticity and freshness is guaranteed, with message
// confidentiality being optional.  The RPC context has this info.

message GetNameRequest {
}

message GetNameResponse {
  string name = 1;
}

message GetSymbolRequest {
}

message GetSymbolResponse {
  string symbol = 1;
}

message GetDecimalsRequest {
}

message GetDecimalsResponse {
  uint32 decimals = 1;  // uint8
}

message GetTotalSupplyRequest {
}

message GetTotalSupplyResponse {
  bytes total_supply = 1;  // AmountType
}

// uint256 is used for stake quantities in this API.  This must
// match the definition of AmountType in the base backend trait
// definition.

// Per-caller state:
//  uint256 amount:  total stake amount
//  uint256 escrowed:  amount of stake in escrow

// Invariants:
//
// 0 <= escrowed <= amount <= MAX_UINT256
//
// The authenticated caller can get their own stake information.  For
// now, we do not expect it to be useful/desirable to query for other
// entity's stake availability etc, though that could change.
message GetStakeStatusRequest {
  bytes owner = 1;
}

message GetStakeStatusResponse {
  bytes total_stake = 1;
  bytes escrowed_stake = 2;
}
// Available stake for withdrawal is total_stake - escrowed_stake.

message BalanceOfRequest {
  bytes owner = 1;
}

message BalanceOfResponse {
  bytes available_balance = 1;
}

// Transfer |amount| stake from the stake account belonging to
// |msg_sender| to that belonging to |target|.  If no account exists
// for |target|, it is automatically created.
message TransferRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes destination_address = 2;
  bytes value = 3;
}

// If there is no overflow in adding to the target account, or
// underflow in deducting from the msg_sender account, then the null
// response would indicate success.  Otherwise an error would be
// reported.
message TransferResponse {
  bool success = 1;
}

message TransferFromRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes source_address = 2;
  bytes destination_address = 3;
  bytes value = 4;
}

message TransferFromResponse {
  bool success = 1;
}

message ApproveRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes spender_address = 2;
  bytes value = 3;
}

message ApproveResponse {
  bool success = 1;
}

message ApproveAndCallRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes spender_address = 2;
  bytes value = 3;
  bytes extra_data = 4;
}

message ApproveAndCallResponse {
  bool success = 1;
}

message AllowanceRequest {
  bytes owner_address = 1;
  bytes spender_address = 2;
}

message AllowanceResponse {
  bytes remaining = 1;
}

message BurnRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes value = 2;
}

message BurnResponse {
  bool success = 1;
}

message BurnFromRequest {
  bytes msg_sender = 1; // should be RpcContext info
  bytes owner_address = 2;
  bytes value = 3;
}

message BurnFromResponse {
  bool success = 1;
}

// The authenticated caller takes some portion of their available stake
// and adds it to escrow.  If the caller misbehaves, a part of the escrow
// is taken away during dispute resolution.  When the caller wants to leave
// the computation group, the remainder of the escrow is returned.
//
// If caller.stake - caller.escrowed >= AddEscrowRequest.escrow_amount
// then
//   caller.escrowed += AddEscrowRequest.escrow_amount
//   failure_code = Ok(caller.escrowed)
// otherwise
//   caller state unchanged
//   failure_code = Err(WouldOverflow)
message AddEscrowRequest {
  bytes msg_sender = 1;
  bytes escrow_amount = 3;
}

message AddEscrowResponse {
  // Failure reasons: Err(NoStakeAccount), Err(InsufficientFunds).
  bytes total_escrow_so_far = 1; // AmountType
}

message FetchEscrowAmountRequest {
  bytes owner = 1;
}

message FetchEscrowAmountResponse {
  // Possible errors: Err(NoStakeAccount).
  bytes amount = 3;
}

// msg_sender should have an account, or one will be created for it.
message TakeEscrowRequest {
  bytes msg_sender = 1;
  bytes owner = 2;
  bytes amount_requested = 3;
}

message TakeEscrowResponse {
  // Possible failures: Err(NoStakeAccount), Err(RequestExceedsEscrowedFunds).
  bytes amount_taken = 1;
  // amount transferred to target (caller)'s stake account.  If there
  // is no Err(..), amount_taken should always equal amount_requested
  // in the request message.
}

message ReleaseEscrowRequest {
  bytes msg_sender = 1;
  bytes owner = 2;
}

message ReleaseEscrowResponse {
  // Possible failures: Err(NoStakeAccount).
  bytes amount_returned = 1;
}

// The LinkToDisputeResolution and LinkToEntityRegistry calls notify the Stake
// about the deployment addresses of those two, so it can properly check if
// TakeEscrow calls are issued only by the DisputeResolution and ReleaseEscrow
// only by the EntityRegistry.  These addresses can only be set once, right
// after the Stake, the DisputeResolution, and the EntityRegistry are all
// initialized and have known addresses.  We can't do this at Stake
// initialization time, since the other two depend on Stake, but Stake depends
// on the other two (but only for escrows).
message LinkToDisputeResolutionRequest {
  bytes address = 1;
}

message LinkToDisputeResolutionResponse {
  // Possible failures: Err(AddressAlreadySet).
  bool success = 1;
}

message LinkToEntityRegistryRequest {
  bytes address = 1;
}

message LinkToEntityRegistryResponse {
  // Possible failures: Err(AddressAlreadySet).
  bool success = 1;
}
