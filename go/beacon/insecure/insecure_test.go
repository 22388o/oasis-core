package insecure

import (
	"encoding/hex"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"golang.org/x/net/context"

	epochtime "github.com/oasislabs/ekiden/go/epochtime/api"
	"github.com/oasislabs/ekiden/go/epochtime/mock"
)

func TestBeaconInsecure(t *testing.T) {
	const (
		farFuture   = 0xcafebabedeadbeef
		recvTimeout = 1 * time.Second
	)

	timeSource := mock.New()
	r := New(timeSource)

	// Known Answer Tests taken from the Rust implementation, which
	// originally were generated by a throw-away Go snippet.

	b, err := r.GetBeacon(context.Background(), 0)
	require.NoError(t, err, "GetBeacon(0)")
	require.Equal(
		t,
		"0c2d4edf3c57c2071f8856d1f74cb126455c2df949a2e3638509b20f8bd5e85d",
		hex.EncodeToString(b),
		"GetBeacon(0)",
	)

	ch, sub := r.WatchBeacons()
	defer sub.Close()
	select {
	case ev := <-ch:
		require.Equal(t, epochtime.EpochTime(0), ev.Epoch, "Event[0]: Epoch")
		require.EqualValues(t, b, ev.Beacon, "Event[0]: Beacon")
	case <-time.After(recvTimeout):
		t.Fatalf("Failed to receive current beacon on WatchBeacons()")
	}

	b, err = r.GetBeacon(context.Background(), farFuture)
	require.NoError(t, err, "GetBeacon(0)")
	require.Equal(
		t,
		"36ae91d1c4c40e52bcaa86f5cbb8fe514f36e5165c721b18f5feabc25fb0aa84",
		hex.EncodeToString(b),
		"GetBeacon(0x%x)",
		uint64(farFuture),
	)

	timeSource.SetEpoch(context.Background(), farFuture, 0)

	select {
	case ev := <-ch:
		require.Equal(t, epochtime.EpochTime(farFuture), ev.Epoch, "Event[farFuture]: Epoch")
		require.EqualValues(t, b, ev.Beacon, "Event[farFuture]: Beacon")
	case <-time.After(recvTimeout):
		t.Fatalf("Failed to receive beacon notification after transition")
	}
}
